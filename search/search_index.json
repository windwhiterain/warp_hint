{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Warp Hint","text":"<p>Nvidia Warp is currently the most advanced GPGPU DSL. However, its language feature is poor. This project aims to provide a language feature rich wrapper around Nvidia Wrap, especially type-hint.</p> <p></p>"},{"location":"features/alias_resolve/","title":"Alias Resolve","text":"<p><code>warp</code> can't infer type alias in parameter annotations in kernel function. <pre><code>type A = int\n\n@warp.kernel\ndef func(a: A): ...\n</code></pre></p> <p>In this example, <code>A</code> is a type alias of <code>int</code>, but use it to annote parameter <code>a</code> in kernel function <code>func</code> is invalid. However <code>warp_hint</code> let you do this:</p> <pre><code>from warp_hint import kernel \n\ntype A = int\n\n@kernel\ndef func(a: A): ...\n</code></pre> <p>Although most of the time you can use the older version of alias in <code>warp</code>:</p> <pre><code>A = int\n</code></pre> <p>But when it comes to generic alias:</p>"},{"location":"features/alias_resolve/#generic-alias-resolve","title":"Generic Alias Resolve","text":"<pre><code>A[t] = list[t]\nB[t] = t\nC[k,v] = dict[k,v]\nD[k] = C[k,int]\nE[k,v] = C[k,D[k]]\n\n@kernel\ndef func(a: A[int], ... ,e: E[int,float]): ...\n</code></pre> <p><code>warp_hint</code> will resolve all valid generic alias for you.</p> <p><code>warp</code> does not support generic type in python's type system, so you can't actually use <code>list[t]</code> nor <code>dict[k,v]</code> in kernel type annotations. However, <code>warp_hint</code> let you use generic wrapper type.</p>"},{"location":"features/kernel_call/","title":"Kernel Call","text":"<p>In <code>warp</code>, launching a kernel is tedious and lost all type-hint of the kernel function:</p> <pre><code>@warp.kernel\ndef func(a: int, b: float): ...\n\nwarp.launch(func, shape, inputs = (1, 1.0))\n</code></pre> <p><code>warp_hint</code> enable you directly call the kernel function with <code>shape</code> provieded in a subsequent call:</p> <pre><code>from warp_hint import kernel \n\n@kernel\ndef func(a: int, b: float): ...\n\nfunc(1, 1.0)(shape) # type-hint is avaliable\n</code></pre>"},{"location":"features/output_marker/","title":"Output Marker","text":"<p>Differential programming in <code>warp</code> requires you place all <code>input</code> parameters ahead of <code>output</code> parameters in kernel function, and provide inputs and outputs accordingly on lauching kernel, which bring implicit constaint and add mental burden on lauching kernel.</p> <pre><code>@warp.kernel\ndef func(read: wp.array(...), write: wp.array(...)): ...\n\nwarp.launch(func, shape, inputs = (read,), outputs = (write,))\n</code></pre> <p>In this example, you have to place <code>read</code> ahead of <code>write</code> in parameters. When defining <code>func</code>, you have no way to tell the type system <code>read</code> is <code>input</code> and <code>write</code> is <code>output</code>, which you have to figure out every time launching <code>func</code>, providing parameters in <code>inputs</code> and <code>outputs</code> correctly.</p> <pre><code>from warp_hint import Out, kernel\n\n@kernel\ndef func(write: Out[wp.array(...)], read: wp.array(...)): ...\n\nfunc(shape, write, read)\n</code></pre> <p>Thanks to alias resolve, <code>warp_hint</code> let you use a generic alias to mark a parameter is <code>output</code>, and place it anywhere in the type annotations of kernel function parameters.</p> <pre><code>@kernel\ndef func(a: Out[int], b: int, c: Out[int], d: int, ...): ...\n\nfunc(a, b, c, d, ...)\n</code></pre> <p>You can very arbitarily mark the <code>output</code> parameters, not affecting the kernel call.</p>"},{"location":"features/real_generic/","title":"Real Generic","text":"<p>Python' generic is kind a fake generic that there is no <code>specialization</code> but <code>generic alias</code>.</p> <pre><code>class A[T]:\n    @classmethod\n    def cls_info(cls):\n        print(T)\n\n    def info(self):\n        print(T)\n\nA[int].static_info() # T\nA[int].cls_info() # T\nA[int]().info() # T\nprint(issubclass(A[int],A)) # False\nprint(isinstance(A[int](),A[int])) # False\nprint(isinstance(A[int](),A)) # True\n</code></pre> <p>In this example, you can't get the resolved value of the type var <code>T</code> in any kind of method of class. Type alias <code>A[int]</code> is not subclass of its origin <code>A</code>, and call type alias <code>A[int]</code> only got a instance of the origin type <code>A</code>.</p> <pre><code>from warp_hint import Generic\n\nclass A[T](Generic):\n    @staticmethod\n    def cls_info(cls):\n        print(cls.type_attr(T))\n\n    def info(self):\n        print(self.type_attr(T))\n\nA[int].cls_info() # int\nA[int]().info() # int\nprint(issubclass(A[int],A)) # True\nprint(isinstance(A[int](),A[int])) # True\nprint(isinstance(A[int](),A)) # True\n</code></pre> <p><code>warp_hint</code> enable all of this, resolved type variable value can be retrieved via a class method <code>type_attr</code>, type alias <code>A[int]</code> become a real <code>specification</code> that subclass <code>A</code>.</p> <p><pre><code>class A: ...\nclass B[t]:...\nclass C[t](A[t]):...\nclass D(A[int]):...\nclass E[k,v](B[k],C[v]): ...\n</code></pre> You can build very arbitary generic classes structure.</p>"},{"location":"features/real_generic/#generic-cache","title":"Generic Cache","text":"<p>Python don't cache <code>generic alias</code> so: <pre><code>print(list[int] is list[int]) # False\nprint(list[int] == list[int]) # True \n</code></pre> <code>warp_hint</code> make it <code>True</code> by cache it. <pre><code>print(list[int] is list[int]) # True\n</code></pre></p>"},{"location":"features/wrapper_type/","title":"Wrapper Type","text":"<p>Thanks to real generic, <code>warp_hint</code> can wrap type created with type parameters into python generic, enbaling type-hint.</p> <pre><code>from warp_hint.wrapper_type import Array\n\ntype ArrayInt1D = Array[A[int], 1]\nprint(Array[A[int], 1].zero(3))\n\na = Array.from_py([1, 1, 1]) # type-hint is avaliable\n</code></pre> <p>In this example, <code>warp_hint</code> provide a builtin wrapper type <code>Array</code> to wrap <code>warp.array</code>.</p>"},{"location":"features/wrapper_type/#generic-wrapper-struct","title":"Generic Wrapper Struct","text":"<p>You can't decorate generic class with <code>@struct</code> in <code>warp</code>, but you can in <code>warp_hint</code>.</p> <pre><code>from warp_hint.wrapper_type import GenericWrapperStruct\n\nclass Point[T](GenericStruct):\n    x: T\n    y: T\n\np = Point[float]()\np.x = 1.0\np.y = 2.0\nprint(p)\n</code></pre> <p>Arbitary nesting:</p> <pre><code>class Segment[T]:\n    start: Point[T]\n    end: Point[T]\n</code></pre>"}]}