{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Warp Hint","text":""},{"location":"features/alias_resolve/","title":"Alias Resolve","text":"<p><code>warp</code> can't infer type alias in parameter annotations in kernel function. <pre><code>type A = int\n\n@warp.kernel\ndef func(a: A): ...\n</code></pre></p> <p>In this example, <code>A</code> is a type alias if <code>int</code>, but use it to annote parameter <code>a</code> in kernel function <code>func</code> is invalid. However <code>warp_hint</code> let you do this:</p> <pre><code>type A = int\n\n@warp_hint.kernel\ndef func(a: A): ...\n</code></pre> <p>Although most of the time you can use the older version of alias in <code>warp</code>:</p> <pre><code>A = int\n</code></pre> <p>But when it comes to generic alias:</p>"},{"location":"features/alias_resolve/#generic-alias-resolve","title":"Generic Alias Resolve","text":"<pre><code>A[t] = list[t]\nB[t] = t\nC[k,v] = dict[k,v]\nD[k] = C[k,int]\nE[k,v] = C[k,D[k]]\n\n@warp_hint.kernel\ndef func(a: A[int], ... ,e: E[int,float]): ...\n</code></pre> <p><code>warp_hint</code> will resolve all valid generic alias for you.</p> <p><code>warp</code> does not support generic type in python's type system, so you can't actually use <code>list[t]</code> nor <code>dict[k,v]</code> in kernel type annotations. However, <code>warp_hint</code> let you use generic wrapper type.</p>"},{"location":"features/kernel_call/","title":"Kernel Call","text":"<p>In <code>warp</code>, launching a kernel is tedious and lost all type-hint of the kernel function:</p> <pre><code>@warp.kernel\ndef func(a: int, b: float): ...\n\nwarp.launch(func, shape, inputs = (1, 1.0))\n</code></pre> <p><code>warp_hint</code> enable you directly call the kernel function with <code>shape</code> added ahead of parameter annotations:</p> <pre><code>@warp.kernel\ndef func(a: int, b: float): ...\n\nfunc(shape, 1, 1.0) # type-hint is avaliable\n</code></pre>"},{"location":"features/output_marker/","title":"Output Marker","text":"<p>Differential programming in <code>warp</code> requires you place all <code>input</code> parameters ahead of <code>output</code> parameters in kernel function, and provide inputs and outputs accordingly on lauching kernel, which bring implicit constaint and add mental burden on lauching kernel.</p> <pre><code>@warp.kernel\ndef func(read: wp.array(...), write: wp.array(...)): ...\n\nwarp.launch(func, shape, inputs = (read,), outputs = (write,))\n</code></pre> <p>In this example, you have to place <code>read</code> ahead of <code>write</code> in parameters. When defining <code>func</code>, you have no way to tell the type system <code>read</code> is <code>input</code> and <code>write</code> is <code>output</code>, which you have to figure out every time launching <code>func</code>, providing parameters in <code>inputs</code> and <code>outputs</code> correctly.</p> <pre><code>from warp_hint import Out\n\n@warp_hint.kernel\ndef func(write: Out[wp.array(...)], read: wp.array(...)): ...\n\nfunc(shape, write, read)\n</code></pre> <p>Thanks to alias resolve, <code>warp_hint</code> let you use a generic alias to mark a parameter is <code>output</code>, and place it anywhere in the type annotations of kernel function parameters.</p> <pre><code>@warp_hint.kernel\ndef func(a: Out[int], b: int, c: Out[int], d: int, ...): ...\n\nfunc(a, b, c, d, ...)\n</code></pre> <p>You can very arbitarily mark the <code>output</code> parameters, not affecting the kernel call.</p>"},{"location":"features/real_generic/","title":"Real Generic","text":"<p>Python' generic is kind a fake generic that there is no specialization but generic alias.</p> <pre><code>class A[T]:\n    @staticmethod\n    def static_info():\n        print(T)\n\n    @classmethod\n    def cls_info(cls):\n        print(T)\n\n    def info(self):\n        print(T)\n\nA[int].static_info() # T\nA[int].cls_info() # T\nA[int]().info() # T\nprint(issubclass(A[int],A)) # False\nprint(isinstance(A[int](),A[int])) # False\nprint(isinstance(A[int](),A)) # True\n</code></pre> <p>In this example, you can't get the resolved value of the type var <code>T</code> in any kind of method of class. Type alias <code>A[int]</code> is not subclass of its origin <code>A</code>, and call type alias <code>A[int]</code> only got a instance of the origin type<code>A</code>.</p> <pre><code>from warp_hint import RealGeneric\n\nclass A[T](RealGeneric):\n    @staticmethod\n    def cls_info(cls):\n        print(cls.type_attr(T))\n\n    def info(self):\n        print(self.type_attr(T))\n\nA[int].cls_info() # int\nA[int]().info() # int\nprint(issubclass(A[int],A)) # True\nprint(isinstance(A[int](),A[int])) # True\nprint(isinstance(A[int](),A)) # True\n</code></pre> <p><code>warp_hint</code> enable all of this, resolved type variable value can be retrieved via a class method <code>type_attr</code>, type alias <code>A[int]</code> become a real specification that subclass <code>A</code>.</p>"}]}