{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Warp Hint Features Alias Resolve Kernel Call Output Marker Real Generic","title":"Home"},{"location":"#warp-hint","text":"","title":"Warp Hint"},{"location":"#features","text":"Alias Resolve Kernel Call Output Marker Real Generic","title":"Features"},{"location":"features/alias_resolve/","text":"Alias Resolve type A = int @warp.kernel def func(a: A): ... warp can't infer the parameter type A in kernel function, warp_hint let you do this: type A = int @warp_hint.kernel def func(a: A): ... Although most of the time you can use the older version of alias to make it pass in warp : A = int However, when it comes to generic alias: Generic Alias Resolve A[t] = list[t] B[t] = t C[k,v] = dict[k,v] D[k] = C[k,int] E[k,v] = C[k,D[k]] @warp_hint.kernel def func(a: A[int], ... ,e: E[int,float]): ... warp_hint will resolve all valid generic alias for you. Although warp does not support generic type in python's type system, you can't actually use list[t] nor dict[k,v] in kernel type annotations, but warp_hint provide that for you.","title":"Alias Resolve"},{"location":"features/alias_resolve/#alias-resolve","text":"type A = int @warp.kernel def func(a: A): ... warp can't infer the parameter type A in kernel function, warp_hint let you do this: type A = int @warp_hint.kernel def func(a: A): ... Although most of the time you can use the older version of alias to make it pass in warp : A = int However, when it comes to generic alias:","title":"Alias Resolve"},{"location":"features/alias_resolve/#generic-alias-resolve","text":"A[t] = list[t] B[t] = t C[k,v] = dict[k,v] D[k] = C[k,int] E[k,v] = C[k,D[k]] @warp_hint.kernel def func(a: A[int], ... ,e: E[int,float]): ... warp_hint will resolve all valid generic alias for you. Although warp does not support generic type in python's type system, you can't actually use list[t] nor dict[k,v] in kernel type annotations, but warp_hint provide that for you.","title":"Generic Alias Resolve"},{"location":"features/kernel_call/","text":"Kernel Call In warp , launching a kernel is tedious and lost all type-hint of the kernel function: @warp.kernel def func(a: int, b: float): ... warp.launch(func, shape, inputs = (1, 1.0)) warp_hint enable you directly call the kernel function with shape added ahead of parameter annotations: @warp.kernel def func(a: int, b: float): ... func(shape, 1, 1.0) # type-hint is avaliable","title":"Kernel Call"},{"location":"features/kernel_call/#kernel-call","text":"In warp , launching a kernel is tedious and lost all type-hint of the kernel function: @warp.kernel def func(a: int, b: float): ... warp.launch(func, shape, inputs = (1, 1.0)) warp_hint enable you directly call the kernel function with shape added ahead of parameter annotations: @warp.kernel def func(a: int, b: float): ... func(shape, 1, 1.0) # type-hint is avaliable","title":"Kernel Call"},{"location":"features/output_marker/","text":"Output Marker Differential programming in warp requires you place all input parameters ahead of output parameters in kernel function, and provide inputs and outputs accordingly on lauching kernel, which bring implicit constaint and add mental burden on lauching kernel. @warp.kernel def func(read: wp.array(...), write: wp.array(...)): ... warp.launch(func, shape, inputs = (read,), outputs = (write,)) In this example, you have to place read ahead of write in parameters. When defining func , you have no way to tell the type system read is input and write is output, which you have to figure out every time launching func , providing parameters in inputs and outputs correctly. from warp_hint import Out @warp_hint.kernel def func(write: Out[wp.array(...)], read: wp.array(...)): ... func(shape, write, read) Thanks to alias resolve , warp_hint let you use a generic alias to mark a parameter is output , and place it anywhere in the type annotations of kernel function parameters. @warp_hint.kernel def func(a: Out[int], b: int, c: Out[int], d: int, ...): ... func(a, b, c, d, ...) You can very arbitarily mark the output parameters, not affecting the kernel call .","title":"Output Marker"},{"location":"features/output_marker/#output-marker","text":"Differential programming in warp requires you place all input parameters ahead of output parameters in kernel function, and provide inputs and outputs accordingly on lauching kernel, which bring implicit constaint and add mental burden on lauching kernel. @warp.kernel def func(read: wp.array(...), write: wp.array(...)): ... warp.launch(func, shape, inputs = (read,), outputs = (write,)) In this example, you have to place read ahead of write in parameters. When defining func , you have no way to tell the type system read is input and write is output, which you have to figure out every time launching func , providing parameters in inputs and outputs correctly. from warp_hint import Out @warp_hint.kernel def func(write: Out[wp.array(...)], read: wp.array(...)): ... func(shape, write, read) Thanks to alias resolve , warp_hint let you use a generic alias to mark a parameter is output , and place it anywhere in the type annotations of kernel function parameters. @warp_hint.kernel def func(a: Out[int], b: int, c: Out[int], d: int, ...): ... func(a, b, c, d, ...) You can very arbitarily mark the output parameters, not affecting the kernel call .","title":"Output Marker"},{"location":"features/real_generic/","text":"Real Generic Python' generic is kind a fake generic that there is no specialization but generic alias. class A[T]: @staticmethod def static_info(): print(T) @classmethod def cls_info(cls): print(T) def info(self): print(T) A[int].static_info() # T A[int].cls_info() # T A[int]().info() # T print(issubclass(A[int],A)) # False print(isinstance(A[int](),A[int])) # False print(isinstance(A[int](),A)) # True In this example, you can't get the resolved value of the type var T in any kind of method of class. Type alias A[int] is not subclass of its origin A , and call type alias A[int] only got a instance of the origin type A . from warp_hint import RealGeneric class A[T](RealGeneric): @staticmethod def cls_info(cls): print(cls.type_attr(T)) def info(self): print(self.type_attr(T)) A[int].cls_info() # int A[int]().info() # int print(issubclass(A[int],A)) # True print(isinstance(A[int](),A[int])) # True print(isinstance(A[int](),A)) # True warp_hint enable all of this, resolved type variable value can be retrieved via a class method type_attr , type alias A[int] become a real specification that subclass A .","title":"Real Generic"},{"location":"features/real_generic/#real-generic","text":"Python' generic is kind a fake generic that there is no specialization but generic alias. class A[T]: @staticmethod def static_info(): print(T) @classmethod def cls_info(cls): print(T) def info(self): print(T) A[int].static_info() # T A[int].cls_info() # T A[int]().info() # T print(issubclass(A[int],A)) # False print(isinstance(A[int](),A[int])) # False print(isinstance(A[int](),A)) # True In this example, you can't get the resolved value of the type var T in any kind of method of class. Type alias A[int] is not subclass of its origin A , and call type alias A[int] only got a instance of the origin type A . from warp_hint import RealGeneric class A[T](RealGeneric): @staticmethod def cls_info(cls): print(cls.type_attr(T)) def info(self): print(self.type_attr(T)) A[int].cls_info() # int A[int]().info() # int print(issubclass(A[int],A)) # True print(isinstance(A[int](),A[int])) # True print(isinstance(A[int](),A)) # True warp_hint enable all of this, resolved type variable value can be retrieved via a class method type_attr , type alias A[int] become a real specification that subclass A .","title":"Real Generic"}]}